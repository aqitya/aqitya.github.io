<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Part 1: Fun with Filters</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
        }
        img {
            width: 100%; /* Responsive images */
            max-width: 400px; /* Limit size to 400px */
        }
        figure {
            display: inline-block;
            margin: 10px;
            text-align: center;
            background-color: #fff;
            padding: 10px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <h1>Part 1: Fun with Filters</h1>

    <h2>Part 1.1: Finite Difference Operator</h2>
    <figure>
        <img src="part1/cameraman.png">
        <figcaption>OG Picture</figcaption>
    </figure>

    <p> First, we compute the partial derivatives of the image in both x and y directions. We also define a ' humble' finite difference as our filter in the x and y directions as Dx = [1 -1] and Dy = [1 -1]^t.</p>

    <h2>Finite Difference Operator</h2>

    <h3>Partial Derivative in X and Y</h3>
    <figure>
        <img src="part1/camermangX.png" alt="Partial Derivative in X">
        <figcaption>Partial Derivative in X</figcaption>
    </figure>
    <figure>
        <img src="part1/camermangY.png" alt="Partial Derivative in Y">
        <figcaption>Partial Derivative in Y</figcaption>
    </figure>

    <p>
        Using these values, we convolve the image with these operators to obtain gradient components Gx and Gy, where Gx is the horizontal changes and vice versa.
        
        The gradient magnitude is calculated as the Euclidean norm of these components, which we can define as Gradient Magnitude = sqrt(Gx^2 + Gy^2). </p>

    <h3>Gradient Magnitude Image</h3>
    <figure>
        <img src="part1/camermangGRAD.png" alt="Gradient Magnitude">
        <figcaption>Gradient Magnitude</figcaption>
    </figure>

    <p> Finally, we can threshold the gradient magnitude to create a binarized mapping where the pixels shown are above the threshold of 0.289.</p>

    <h3>Binarized</h3>
    <figure>
        <img src="part1/camermangBINARIZED.png">
        <figcaption>With a threshold val of 0.289</figcaption>
    </figure>

    <h2>Part 1.2: Derivative of Gaussian (DoG) Filter</h2>

    <p>
        The results are less noisy compared to using just the difference operator, as you can see, the edges appear smoother overall, whereas finer details seem to be filtered out.
    </p>

    <h3> Images </h3>
    <figure>
        <img src="part1/grad_DOG.png">
        <figcaption> Top row shows the Gaus Filter implementation results and the bottom shows the DOG filter</figcaption>
    </figure>

    <p>
        The DoG filter combines smoothing and differentiation into a single operation, which is computationally more efficient. However, notice that the results are actually the same!
        
        In my code implementation, I wrote a line that essentially checks if the two images had values within a very small tolerance to see if they were equal, to which it returned true.</p>
    
    <figure>
        <img src = "part1/grad_DOG_BINARIZED.png">
        <figcaption> BINARIZED </figcaption>
    </figure>



    <h1>Part 2: Fun with Frequencies!</h1>

    <h2>Part 2.1: Image "Sharpening"</h2>

    <>

</body>
</html>
